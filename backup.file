// ------------------- CALLBACK HANDLER -------------------
bot.on('callback_query', (q) => {
  const id = q.message.chat.id;
  const data = q.data;

  bot.answerCallbackQuery(q.id);

  if (!sessions[id]) sessions[id] = {};

  // Back to main menu
  if (data === 'back_to_menu') return startMenu(id);

  // ----------------- DEPOSIT FLOW -----------------
  if (data === 'goto_deposit') {
    const buttons = [
      [{ text: "$50", callback_data: "amt_50" }, { text: "$100", callback_data: "amt_100" }],
      [{ text: "ğŸ  Main Menu", callback_data: "back_to_menu" }]
    ];
    return bot.sendMessage(id, "ğŸ’³ Select Amount:", {
      reply_markup: { inline_keyboard: buttons }
    });
  }

  if (data.startsWith('amt_')) {
    const amt = parseFloat(data.split('_')[1]);
    sessions[id].depositAmount = amt;

    const btns = Object.keys(CRYPTO).map(c => [
      { text: c, callback_data: `pay_${c}` }
    ]);
    btns.push([{ text: "ğŸ  Main Menu", callback_data: "back_to_menu" }]);

    return bot.sendMessage(id, `ğŸ’³ Amount: $${amt}\nSelect Crypto:`, {
      reply_markup: { inline_keyboard: btns }
    });
  }

  if (data.startsWith('pay_')) {
    const coin = data.split('_')[1];
    const depId = "D" + Date.now();

    db.deposits[depId] = {
      userId: id,
      amount: sessions[id].depositAmount,
      crypto: coin,
      status: 'pending'
    };
    saveDB();

    // User message
    bot.sendMessage(
      id,
      `âš ï¸ *PAYMENT REQUIRED*\nAmount: $${sessions[id].depositAmount}\nCoin: ${coin}\nAddress: \`${CRYPTO[coin]}\`\nAfter payment click below.`,
      {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [{ text: "âœ… I Have Paid", callback_data: `paid_${depId}` }],
            [{ text: "ğŸ  Main Menu", callback_data: "back_to_menu" }]
          ]
        }
      }
    );

    // Admin notification
    bot.sendMessage(
      ADMIN_ID,
      `ğŸš¨ *Deposit Submitted*\nUser: ${id}\nAmount: $${sessions[id].depositAmount}\nCoin: ${coin}`,
      {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [{ text: "âœ… Approve", callback_data: `appr_${depId}` }],
            [{ text: "âŒ Reject", callback_data: `rej_${depId}` }]
          ]
        }
      }
    );

    return;
  }

  // User confirms payment
  if (data.startsWith('paid_')) {
    const depId = data.split('_')[1];
    const dep = db.deposits[depId];
    if (!dep) return;

    dep.status = 'waiting_approval';
    saveDB();

    return bot.sendMessage(id, "âœ… Payment marked as sent. Waiting for admin approval.");
  }

  // Admin approves
  if (data.startsWith('appr_') && id === ADMIN_ID) {
    const depId = data.split('_')[1];
    const dep = db.deposits[depId];
    if (!dep || dep.status !== 'waiting_approval') return;

    db.users[dep.userId].balance += dep.amount;
    dep.status = 'approved';
    saveDB();

    bot.sendMessage(
      dep.userId,
      `âœ… Deposit Approved! Balance: $${db.users[dep.userId].balance.toFixed(2)}`
    );

    return bot.editMessageText("âœ… Approved", {
      chat_id: id,
      message_id: q.message.message_id
    });
  }

  // Admin rejects
  if (data.startsWith('rej_') && id === ADMIN_ID) {
    const depId = data.split('_')[1];
    const dep = db.deposits[depId];
    if (!dep || dep.status !== 'waiting_approval') return;

    dep.status = 'rejected';
    saveDB();

    bot.sendMessage(dep.userId, "âŒ Deposit Rejected");

    return bot.editMessageText("âŒ Rejected", {
      chat_id: id,
      message_id: q.message.message_id
    });
  }

  // ----------------- SERVICES FLOW -----------------
  if (data === 'goto_services') {
    const btns = Object.keys(SERVICES).map(p => [{ text: p, callback_data: `plat_${p}` }]);
    btns.push([{ text: "ğŸ  Main Menu", callback_data: "back_to_menu" }]);
    return bot.sendMessage(id, "ğŸ“£ Select Platform:", { reply_markup: { inline_keyboard: btns } });
  }

  if (data.startsWith('plat_')) {
    const plat = data.split('_')[1];
    sessions[id].platform = plat;
    const categories = Object.keys(SERVICES[plat]);
    if (!categories.length) return bot.sendMessage(id, "âŒ No categories yet.");
    const btns = categories.map(c => [{ text: c, callback_data: `cat_${c}` }]);
    btns.push([{ text: "ğŸ  Main Menu", callback_data: "back_to_menu" }]);
    return bot.sendMessage(id, "ğŸ“‚ Select Category:", { reply_markup: { inline_keyboard: btns } });
  }

  if (data.startsWith('cat_')) {
    const cat = data.split('_')[1];
    const plat = sessions[id].platform;
    sessions[id].category = cat;
    const list = SERVICES[plat][cat] || [];
    if (!list.length) return bot.sendMessage(id, "âŒ No services yet.");
    const btns = list.map(s => [{ text: `${s.name} ($${s.price})`, callback_data: `svc_${s.id}` }]);
    btns.push([{ text: "ğŸ  Main Menu", callback_data: "back_to_menu" }]);
    return bot.sendMessage(id, "ğŸ›  Select Service:", { reply_markup: { inline_keyboard: btns } });
  }

  if (data.startsWith('svc_')) {
    const sid = data.split('_')[1];
    let svc;

    // Search for service in all platforms/categories
    for (const plat in SERVICES) {
      for (const cat in SERVICES[plat]) {
        const found = SERVICES[plat][cat].find(s => s.id === sid);
        if (found) {
          svc = found;
          break;
        }
      }
      if (svc) break;
    }

    if (!svc) return bot.sendMessage(id, "âŒ Service not found.");

    // Save service to session
    sessions[id].svc = svc;
    sessions[id].step = 'GET_QTY';

    // Send message with proper line breaks using HTML parse mode
    const msgText =
`â­ <b>${svc.name}</b>

Description:
${svc.desc}

Price per 100 units: $${svc.price}

Minimum order: ${svc.min}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Select quantity below â¬‡ï¸`;

    return bot.sendMessage(id, msgText, {
      parse_mode: 'HTML',
      reply_markup: {
        inline_keyboard: [
          [{ text: "ğŸ  Main Menu", callback_data: "back_to_menu" }]
        ]
      }
    });
  }

  if (data === 'buy_now') {
    const s = sessions[id];
    if (!s || !s.svc || !s.qty || !s.link) return bot.sendMessage(id, "âŒ Session expired");
    const total = (s.qty / 100) * s.svc.price;
    if (db.users[id].balance < total) return bot.sendMessage(id, "âŒ Low balance");

    db.users[id].balance -= total;
    const oid = "O" + Date.now();
    db.orders[oid] = { userId: id, svc: s.svc.name, qty: s.qty, link: s.link, total, status: "Pending" };
    saveDB();
    delete sessions[id];

    bot.sendMessage(id, `âœ… Order placed! Balance: $${db.users[id].balance.toFixed(2)}`);

    // Notify admin
    bot.sendMessage(ADMIN_ID, `ğŸ“¦ New Order\nUser: ${id}\nService: ${s.svc.name}\nQty: ${s.qty}\nLink: ${s.link}`, {
      reply_markup: {
        inline_keyboard: [
          [{ text: "âš™ï¸ Processing", callback_data: `st_proc_${oid}` }],
          [{ text: "âœ… Complete", callback_data: `st_comp_${oid}` }],
          [{ text: "âŒ Reject", callback_data: `st_rej_${oid}` }]
        ]
      }
    });
  }

  // ----------------- USER ORDERS -----------------
  if (data === 'goto_orders') {
    const myOrders = Object.values(db.orders).filter(o => o.userId === id);
    if (!myOrders.length) return bot.sendMessage(id, "ğŸ“¦ No orders yet.");
    const txt = myOrders.map(o => `ğŸ“¦ ${o.svc} | Qty: ${o.qty} | Status: ${o.status}`).join("\n");
    return bot.sendMessage(id, txt);
  }

  // ----------------- ADMIN DASHBOARD -----------------
  if (data === 'admin_dashboard' && id === ADMIN_ID) {
    const btns = [
      [{ text: "ğŸ‘¥ Users", callback_data: "admin_users" }],
      [{ text: "ğŸ“¦ Orders", callback_data: "admin_orders" }],
      [{ text: "ğŸ’³ Deposits", callback_data: "admin_deposits" }],
      [{ text: "ğŸ  Main Menu", callback_data: "back_to_menu" }]
    ];
    return bot.sendMessage(id, "ğŸ‘‘ Admin Dashboard", { reply_markup: { inline_keyboard: btns } });
  }

  if (data === 'admin_users' && id === ADMIN_ID) {
    let txt = "ğŸ‘¥ Users:\n";
    for (const uid in db.users) txt += `${uid}: $${db.users[uid].balance.toFixed(2)}\n`;
    return bot.sendMessage(id, txt, { reply_markup: { inline_keyboard: [[{ text: "ğŸ  Main Menu", callback_data: "back_to_menu" }]] } });
  }

  if (data === 'admin_deposits' && id === ADMIN_ID) {
    let txt = "ğŸ’³ Deposits:\n";
    for (const dId in db.deposits) {
      const dep = db.deposits[dId];
      txt += `${dId}: User ${dep.userId} | $${dep.amount} | ${dep.crypto} | ${dep.status}\n`;
    }
    return bot.sendMessage(id, txt, { reply_markup: { inline_keyboard: [[{ text: "ğŸ  Main Menu", callback_data: "back_to_menu" }]] } });
  }

  // ----------------- SUPPORT -----------------
  if (data === 'goto_support') {
    sessions[id].step = 'SUPPORT';
    return bot.sendMessage(id, "ğŸ’¬ Send your message for support:");
  }

  if (data.startsWith('arep_') && id === ADMIN_ID) {
    const uid = data.split('_')[1];
    sessions[id].step = 'REPLYING';
    sessions[id].target = uid;
    return bot.sendMessage(id, "ğŸ’¬ Reply to user:");
  }

  // ----------------- ORDER STATUS UPDATE -----------------
  if (data.startsWith('st_') && id === ADMIN_ID) {
    const [,, status, oid] = data.split('_');
    const order = db.orders[oid];
    if (!order) return;
    if (status === 'proc') order.status = 'Processing';
    else if (status === 'comp') order.status = 'Completed';
    else if (status === 'rej') order.status = 'Rejected';

    saveDB();
    bot.sendMessage(order.userId, `ğŸ“¦ Your order ${order.svc} is now *${order.status}*`, { parse_mode: 'Markdown' });
    bot.editMessageText(`âœ… Updated: ${order.status}`, { chat_id: id, message_id: q.message.message_id });
  }
});



------------------------------------------------------